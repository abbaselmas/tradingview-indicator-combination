//@version=5
indicator(title='VP-Period', shorttitle='Abbas3', overlay=true, precision=4, linktoseries=true, max_bars_back=1000, max_lines_count=500)

var bool is_first_candle= true
var diff = 0.0
float maxV = 0.0
int maxV_index = 0
int last_time = 0
margin=0.0
ys=0.0
int bar_offset=0
var is_first_inRange=false

period_time   		= input.int(15, "Number of days (Min: 3, Max: 500)", minval = 3, maxval = 500)
resolution   		= input.int(500, "calculation resolution (Min: 400, Max: 700)", minval  = 400, maxval  = 700)
show_from   		= input.int(3, "show support/resistance since (Min: 2, Max: 45)", minval  = 2, maxval  = 45)
show_volume_bars  	= input.bool(false, "Show volume bars (If selected, maximum days are 17)")
show_vpoc_line   	= input.bool(true, "Show VPOC line")
show_support_line   = input.bool(false, "Show support line")
show_res_line   	= input.bool(false, "Show resistance line")
show_H_line   		= input.bool(false, "Show high line")
show_L_line  		= input.bool(false, "Show low line")
show_labels   		= input.bool(false, "Show from days label")
vpoc_color   		= input.color(color.new(#FF0015, 10), "VPOC color")
high_low_color 		= input.color(color.new(color.blue, 50), "High-low lines color")
volume_bars_color   = input.color(color.new(color.green, 70), "Volume bars color")
sup_color 			= input.color(color.new(color.red, 10), "Support line color")
res_color 			= input.color(color.new(color.green, 10),"Resistance line color")

range_prices = array.new_float((resolution + 1), 0.0)
partial_vol = array.new_float(resolution, 0.0)
total_vol = array.new_float(resolution, 0.0)
var all_ys = array.new_float(show_from, 0.0)
var ys_time = array.new_float(show_from, 0.0)
var is_support = array.new_bool(show_from, true)

t = time("1440", session.regular)
var int startTime =time
int ncandles =0

if barstate.isfirst
	startTime := timenow - period_time*86400000

bar_offset:= ta.barssince(is_first_inRange)
is_first = na(t[1]) and not na(t) or t[1] < t
is_first_inRange:=is_first and t>startTime
high_price=0.0
low_price=0.0
price_level=0.0

if is_first_inRange or barstate.islast
	
	last_time:= t[1]
	ncandles := bar_offset
	current_low_price=0.0
	for i = 1 to (ncandles)
		current_low_price:=low[i]
		if current_low_price < low_price or low_price==0.0
			low_price:=current_low_price
			
	current_high_price=0.0
	for i = 1 to (ncandles)
		current_high_price:=high[i]
		if current_high_price >high_price or high_price==0.0
			high_price:=current_high_price
	diff := (high_price-low_price)/resolution
	
	for j = 0 to (resolution)
		array.set(range_prices, (j), (low_price + (diff * (j+1))))
	
	for i = 0 to (ncandles)
		int w_candle = 0
		array.fill(partial_vol, 0.0)
		
		for j=0 to (resolution-1)
			float current_price = array.get(range_prices, j)
			if high[i] > current_price and low[i] < current_price
				float j_partial_vol = array.get(partial_vol, j)
				float sum_vol = j_partial_vol + nz(volume[i])
				array.set(partial_vol, j, sum_vol)
				w_candle := w_candle + 1
		
		for j = 0 to (resolution - 1)
			float j_total_vol = array.get(total_vol, j)
			float j_partial_vol = array.get(partial_vol, j)
			float sum_partial_total=0.0
			if w_candle > 0
				sum_partial_total := j_total_vol + j_partial_vol/w_candle
			else 
				sum_partial_total := j_total_vol
			array.set(total_vol, j, sum_partial_total)
	maxV := array.max(total_vol)
	maxV_index := array.indexof(total_vol, maxV)
	
	if is_first_inRange
		price_level:=diff*maxV_index+low_price
		if high_price - price_level > price_level - low_price
			margin:=high_price - price_level
			ys:=price_level - margin
		else
			margin:=price_level - low_price
			ys:=price_level + margin
		if ys > high_price
			array.shift(is_support)
			array.push(is_support, false)
		else
			array.shift(is_support)
			array.push(is_support, true)
		array.shift(all_ys)
		array.push(all_ys, ys)
		array.shift(ys_time)
		array.push(ys_time, t) 

if barstate.islast
	for i=0 to (show_from - 1)
		ys := array.get(all_ys, i)
		time_back = array.get(ys_time, i)
		if array.get(is_support, i)
			if show_support_line
				line.new(x1=int(time_back), y1=ys, x2=time + 86400000, y2=ys, color=sup_color ,xloc= xloc.bar_time, extend = extend.none, width=2, style=line.style_dashed)
		else
			if show_res_line
				line.new(x1=int(time_back), y1=ys, x2=time + 86400000, y2=ys, color=res_color ,xloc= xloc.bar_time, extend = extend.none, width=2, style=line.style_dashed)
			
		if show_labels    
			label.new(int(time + 86400000), ys, text ="From days: " + str.tostring(show_from - i), xloc=xloc.bar_time)
	
dif_time=0.0

if is_first_inRange or barstate.islast

	last_time:= int(t[1])
	dif_time:= (time-last_time)
	if dif_time/86400000 > 1.5
		dif_time:=(dif_time)/9
	else
		dif_time:=(dif_time)/3
	diff_t=0
	x1=0.0
	norm_vol=0.0
	proportion=resolution/40
	for i = 0 to (resolution - 1)
		y=array.get(range_prices,i)
		current_vol= array.get(total_vol,i)
		norm_vol :=current_vol/maxV
		x1 :=dif_time*norm_vol
		diff_t := last_time + int(x1)
		if (i % int(proportion) == 0 or int(proportion) == 0) and show_volume_bars
			line.new(x1=t[1], y1=y, x2=diff_t, y2=y, color=volume_bars_color ,xloc= xloc.bar_time, extend = extend.none, width=2)

	if show_L_line    
		line.new(x1=t[1], y1=low_price, x2=time, y2=low_price,xloc= xloc.bar_time, color=high_low_color)
	if show_vpoc_line
		line.new(x1=t[1], y1=diff*maxV_index+low_price, x2=time, y2=diff*maxV_index+low_price, color=vpoc_color, width=2,xloc= xloc.bar_time)
	if show_H_line 
		line.new(x1=t[1], y1=high_price, x2=time, y2=high_price,xloc= xloc.bar_time, color=high_low_color)

////////////////////////////////////////////////////////////////////////////////////////
// Balanced Price Range
bpr_threshold = input.float(0, step = 0.25, title = "BPR Threshold", tooltip = "Valid BPR's must have a range greater than this number")
bars_since = input(15, "Bars to Look Back for BPR", tooltip = "Only look for BPR's when a sequence of bearish and bullish FVG's are within this many bars of each other")
only_clean_bpr = input(false, "Only Clean BPR", tooltip = "Only show BPR's when price does not interfere with the range prior to its completion")
delete_old_bpr = input(true, "Delete Old BPR", tooltip = "Delete all BPR's that have been invalidated or overwritten. Only show current/active BPR's")
bearish_bpr_color = input.color(color.new(color.green, 70))
bullish_bpr_color = input.color(color.new(color.green, 70))

float box_high = na
float box_low = na
int box_left = 0
int box_right = 0
var box box_bearish = na
var box box_bullish = na

new_fvg_bearish = low[2] - high > 0
new_fvg_bullish = low - high[2] > 0

valid_high = high[1] > high[2] and high[1] > high[0]
valid_low = low[1] < low[2] and low[1] < low[0]

midline = (high - low) / 2 + low
valid_hammer = open > midline and close > midline
valid_shooter = open < midline and close < midline

// Bullish BPR
bull_num_since = ta.barssince(new_fvg_bearish)
bull_bpr_cond_1 = new_fvg_bullish and bull_num_since <= bars_since 
bull_bpr_cond_2 = bull_bpr_cond_1 ? high[bull_num_since] + low[bull_num_since + 2] + high[2] + low > math.max(low[bull_num_since + 2], low) - math.min(high[bull_num_since], high[2]) : na

bull_combined_low = bull_bpr_cond_2 ? math.max(high[bull_num_since], high[2]) : na
bull_combined_high = bull_bpr_cond_2 ? math.min(low[bull_num_since + 2], low) : na

bull_bpr_cond_3 = true

if only_clean_bpr 
    for h = 2 to (bull_num_since)
        if high[h] > bull_combined_low
            bull_bpr_cond_3 := false

bull_result = bull_bpr_cond_1 and bull_bpr_cond_2 and bull_bpr_cond_3 and (bull_combined_high - bull_combined_low >= bpr_threshold)

if bull_result[1]
    if delete_old_bpr and not na(box_bullish)
        box.delete(box_bullish)
    box_bullish := box.new(bar_index - bull_num_since - 1, bull_combined_high[1], bar_index + 1, bull_combined_low[1], border_color = bullish_bpr_color, border_width = 1, bgcolor = bullish_bpr_color)
alertcondition(bull_result[1], "Bullish Alert", "New Bullish BPR")

if not na(box_bullish) and low > box.get_bottom(box_bullish)
    box.set_right(box_bullish, bar_index + 1)
else if not na(box_bullish) and low < box.get_bottom(box_bullish)
    if delete_old_bpr
        box.delete(box_bullish)
    else
        box_bullish := na 

// Bearish BPR
bear_num_since = ta.barssince(new_fvg_bullish)
bear_bpr_cond_1 = new_fvg_bearish and bear_num_since <= bars_since 
bear_bpr_cond_2 = bear_bpr_cond_1 ? high[bear_num_since] + low[bear_num_since + 2] + high[2] + low > math.max(low[bear_num_since + 2], low) - math.min(high[bear_num_since], high[2]) : na

bear_combined_low = bear_bpr_cond_2 ? math.max(high[bear_num_since + 2], high) : na
bear_combined_high = bear_bpr_cond_2 ? math.min(low[bear_num_since], low[2]) : na

bear_bpr_cond_3 = true

if only_clean_bpr 
    for h = 2 to (bear_num_since)
        if low[h] < bear_combined_high
            bear_bpr_cond_3 := false

bear_result = bear_bpr_cond_1 and bear_bpr_cond_2 and bear_bpr_cond_3 and (bear_combined_high - bear_combined_low >= bpr_threshold)

if bear_result[1]
    if delete_old_bpr and not na(box_bearish)
        box.delete(box_bearish)
    box_bearish := box.new(bar_index - bear_num_since - 1, bear_combined_high[1], bar_index + 1, bear_combined_low[1], border_color = bearish_bpr_color, border_width = 1, bgcolor = bearish_bpr_color)
alertcondition(bear_result[1], "Bearish Alert", "New Bearish BPR")

if not na(box_bearish) and high < box.get_top(box_bearish)
    box.set_right(box_bearish, bar_index + 1)
else if not na(box_bearish) and high > box.get_top(box_bearish)
    if delete_old_bpr
        box.delete(box_bearish)
    else
        box_bearish := na