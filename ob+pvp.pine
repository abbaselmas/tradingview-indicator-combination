//Combined version of 
//https://www.tradingview.com/v/zSDlR0YP/
//https://www.tradingview.com/v/WWqoUu7e/
// © meliksah55
//@version=5
indicator(title='OB+PVP+Weeknd+Opens', overlay=true, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 5000)

bool        pv2_sv          = input.bool        (false,                          title='Plot 2nd order pivots')
bool        msb_sv          = input.bool        (true,                           title='Plot MSB lines')
bool        box_sv          = input.bool        (true,                           title='Plot Orderblocks')
bool        m_sv            = input.bool        (false,                          title='Plot Breakerblocks')
bool        range_sv        = input.bool        (true,                           title='Plot Range')
bool        range_eq_sv     = input.bool        (true,                           title='Plot Range 0.5 Line')
bool        range_q_sv      = input.bool        (true,                           title='Plot Range 0.25 and 0.75 Lines')
bool        log_sv          = input.bool        (false,                          title='Use Log Scale')
bool        msb_a_sv        = input.bool        (false,                          title='Alert MSB')
bool        ob_a_sv         = input.bool        (false,                          title='Alert Orderblock test')
bool        bb_a_sv         = input.bool        (false,                          title='Alert Breakerblock test')
bool        r_a_sv          = input.bool        (false,                          title='Alert New Range')
bool        rt_a_sv         = input.bool        (false,                          title='Alert Range test')
color       u_s             = input.color       (color.new(#089981, 70),         title='Untested Supply Color')
color       t_s             = input.color       (color.new(#b2b5be, 70),         title='Tested Supply Color')
color       u_d             = input.color       (color.new(#f23645, 70),         title='Untested Demand Color')
color       t_d             = input.color       (color.new(#b2b5be, 70),         title='Tested Demand Color')
color       u_b             = input.color       (color.new(#ff9800, 70),         title='Untested Breaker Color')
color       t_b             = input.color       (color.new(#b2b5be, 70),         title='Tested Breaker Color')

var float[] pvh1_price      = array.new_float   (30, na)            // high
var int[]   pvh1_time       = array.new_int     (30, na)
var float[] pvl1_price      = array.new_float   (30, na)            // low
var int[]   pvl1_time       = array.new_int     (30, na)
var float[] pvh2_price      = array.new_float   (10, na)            // higher high
var int[]   pvh2_time       = array.new_int     (10, na)
var float[] pvl2_price      = array.new_float   (10, na)            // lower low
var int[]   pvl2_time       = array.new_int     (10, na)
var float   htcmrll_price   = na                                    // high that created most recent ll
var int     htcmrll_time    = na
var float   ltcmrhh_price   = na                                    // low that created most recent hh
var int     ltcmrhh_time    = na
var box[]   long_boxes      = array.new_box()                       // orderblocks
var box[]   short_boxes     = array.new_box()
var box[]   m_long_boxes    = array.new_box()                       // breakerblocks
var box[]   m_short_boxes   = array.new_box()
var line[]  bull_bos_lines  = array.new_line()                      // MSB lines
var line[]  bear_bos_lines  = array.new_line()
var line[]  range_h_lines   = array.new_line()                      // Range lines
var line[]  range_25_lines  = array.new_line()
var line[]  range_m_lines   = array.new_line()
var line[]  range_75_lines  = array.new_line()
var line[]  range_l_lines   = array.new_line()
var label[] la_ph2          = array.new_label()                     // 2nd order pivots
var label[] la_pl2          = array.new_label()
var float   temp_pv_0       = na
var float   temp_pv_1       = na
var float   temp_pv_2       = na
var int     temp_time       = na
var float   last_range_h    = na
var float   last_range_l    = na
var line    range_m         = na
var line    range_25        = na
var line    range_75        = na
var float   box_top         = na
var float   box_bottom      = na
var int     h_a_time        = 0
var int     l_a_time        = 0
var int     mh_a_time       = 0
var int     ml_a_time       = 0
var int     rh_a_time       = 0
var int     rl_a_time       = 0
bool        pvh             = high < high[1] and high[1] > high[2]
bool        pvl             = low > low[1] and low[1] < low[2]
int         pv1_time        = bar_index[1]
float       pv1_high        = high[1]
float       pv1_low         = low[1]
bool        new_ph_2nd      = false
bool        new_pl_2nd      = false
string      alert           = na

multiplier = input.float(2.6, minval=0, maxval=10, step=0.02, group = "Weekend")

day_clr = dayofweek < 2 or dayofweek > 6 ? color.new(#9598a1, 75) : color.new(#9598a1, 100)
//plot(((high / low) * ohlc4) * (1 + multiplier / 100), style=plot.style_areabr, color=day_clr)
plot( ((low / high) * ohlc4) * (1 - multiplier / 100), style=plot.style_areabr, color=day_clr)

tf = input.timeframe("D", title = "Timeframe", inline = "0", group = "PROFILE SETTINGS")
mdr = input.float(4, minval = 1,maxval = 4,title = "Sensitivity ", inline = "1", group = "PROFILE SETTINGS", tooltip = "Higher = More Granular\nLower = Less Granular")
vap = input.float(70, title = "Value Area %", inline = "1_1", group = "PROFILE SETTINGS")/100
mp = input.bool(false, title = "Calculate As Market Profile", inline = "2", group = "PROFILE SETTINGS", tooltip = "Calculations will distribue a 1 instead of the candle's volume.")
disp_size = input.int(-30, minval = -500,maxval = 500,title  = "Display Size   ", inline = "3", group = "DISPLAY SETTINGS", tooltip = "The entire range of your profile will scale to fit inside this range.\nNotes:\n-This value is # bars away from your profile's axis.\n-The larger this value is, the more granular your (horizontal) view will be. This does not change the Profiles' value; because of this, sometimes the POC looks tied with other values widely different. The POC CAN be tied to values close to it, but if the value is far away it is likely to just be a visual constraint.\n-This Value CAN be negative")
prof_offset = input.int(50, minval = -500,maxval = 500, title  = "Display Offset", inline = "4", group = "DISPLAY SETTINGS", tooltip = "Offset your profile's axis (Left/Right) to customize your display to fit your style.\nNotes:\n-Zero = Current Bar\n-This Value CAN be negative")
extend_day = input.bool(true, title = "Display Current POC/VAH/VAL", inline = "5", group = "Additional Data Displays")
hist = input.bool(true, title = "Display Historical POC/VAH/VAL", inline = "6", group = "Additional Data Displays")
poc_color = input.color(#ff033e, title = "POC Color", group = "Colors")
var_color = input.color(#00bcd4, title = "Value High/Low Color", group = "Colors")
vaz_color = input.color(color.new(#555555,50), title = "Value Zone Color", group = "Colors")
ov_color = input.color(#555555, title = "Profile Color", group = "Colors")
sp_color = input.color(#801922, title  = "Lowest Value Color", group = "Colors")

if barstate.isconfirmed
    if pvh
        array.pop(pvh1_price)
        array.pop(pvh1_time)
        array.unshift(pvh1_price, pv1_high)
        array.unshift(pvh1_time, pv1_time)
        if array.size(pvh1_price) > 2
            temp_pv_0 := array.get(pvh1_price, 0)
            temp_pv_1 := array.get(pvh1_price, 1)
            temp_pv_2 := array.get(pvh1_price, 2)
            if temp_pv_0 < temp_pv_1 and temp_pv_1 > temp_pv_2
                array.pop(pvh2_price)
                array.pop(pvh2_time)
                array.unshift(pvh2_price, temp_pv_1)
                array.unshift(pvh2_time, array.get(pvh1_time, 1))
                new_ph_2nd := true
                if temp_pv_1 > array.get(pvh2_price, 1)
                    for i = 0 to array.size(pvl2_time) - 1 by 1
                        temp_ltcmrhh_time = array.get(pvl2_time, i)
                        if temp_ltcmrhh_time < array.get(pvh2_time, 0)
                            ltcmrhh_price := array.get(pvl2_price, i)
                            ltcmrhh_time := temp_ltcmrhh_time
                            break
            if temp_pv_0 < ltcmrhh_price
                if msb_sv
                    array.push(bear_bos_lines, line.new(x1=ltcmrhh_time, y1=ltcmrhh_price, x2=bar_index, y2=ltcmrhh_price, color=color.green, width=2))
                box_top := array.get(pvh2_price, 0)
                box_bottom := math.max(low[bar_index - array.get(pvh2_time, 0)], low[bar_index - array.get(pvh2_time, 0) + 1])
                array.push(short_boxes, box.new(left=array.get(pvh2_time, 0), top=box_top, right=bar_index, bottom=box_bottom, bgcolor= box_sv ? u_s : na , border_color=na, extend=extend.right))
                if msb_a_sv
                    alert := alert + 'Bearish MSB @ ' + str.tostring(ltcmrhh_price) + '\n' + 'New Supply Zone : '+ str.tostring(box_top) + ' - ' + str.tostring(box_bottom) + '\n'
                ltcmrhh_price := na
    if pvl
        array.pop(pvl1_price)
        array.pop(pvl1_time)
        array.unshift(pvl1_price, pv1_low)
        array.unshift(pvl1_time, pv1_time)
        if array.size(pvl1_price) > 2
            temp_pv_0 := array.get(pvl1_price, 0)
            temp_pv_1 := array.get(pvl1_price, 1)
            temp_pv_2 := array.get(pvl1_price, 2)
            if temp_pv_0 > temp_pv_1 and temp_pv_1 < temp_pv_2
                array.pop(pvl2_price)
                array.pop(pvl2_time)
                array.unshift(pvl2_price, temp_pv_1)
                array.unshift(pvl2_time, array.get(pvl1_time, 1))
                new_pl_2nd := true
                if temp_pv_1 < array.get(pvl2_price, 1)
                    for i = 0 to array.size(pvh2_time) - 1 by 1
                        temp_htcmrll_time = array.get(pvh2_time, i)
                        if temp_htcmrll_time < array.get(pvl2_time, 0)
                            htcmrll_price := array.get(pvh2_price, i)
                            htcmrll_time := temp_htcmrll_time
                            break
            if temp_pv_0 > htcmrll_price
                if msb_sv
                    array.push(bull_bos_lines, line.new(x1=htcmrll_time, y1=htcmrll_price, x2=bar_index, y2=htcmrll_price, color=color.red, width=2))
                box_top := math.min(high[bar_index - array.get(pvl2_time, 0)], high[bar_index - array.get(pvl2_time, 0) + 1])
                box_bottom := array.get(pvl2_price, 0)
                array.push(long_boxes, box.new(left=array.get(pvl2_time, 0), top=box_top, right=bar_index, bottom=box_bottom, bgcolor= box_sv ? u_d : na, border_color=na, extend=extend.right))
                if msb_a_sv
                    alert := alert + 'Bullish MSB @ ' + str.tostring(htcmrll_price) + '\n' + 'New Demand Zone : '+ str.tostring(box_bottom) + ' - ' + str.tostring(box_top) + '\n'
                htcmrll_price := na
    if array.size(short_boxes) > 0
        for i = array.size(short_boxes) - 1 to 0 by 1
            tbox = array.get(short_boxes, i)
            top = box.get_top(tbox)
            bottom = box.get_bottom(tbox)
            ago = box.get_left(tbox)
            if array.get(pvh1_price, 0) > bottom 
                if box_sv
                    box.set_bgcolor(tbox, t_s)    
                if ob_a_sv and close < bottom
                    if array.get(pvh1_time, 0) != h_a_time
                        h_a_time := array.get(pvh1_time, 0)
                        alert := alert + 'Supply Zone Test @ ' + str.tostring(array.get(pvh1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvl1_price, 0) > top
                if m_sv
                    box.set_bgcolor(tbox, u_b)
                    array.push(m_long_boxes, tbox)
                else
                    box.delete(tbox)
                array.remove(short_boxes, i)
                if msb_sv    
                    line.delete(array.get(bear_bos_lines, i))
                    array.remove(bear_bos_lines, i)
    if array.size(long_boxes) > 0
        for i = array.size(long_boxes) - 1 to 0 by 1
            lbox = array.get(long_boxes, i)
            top = box.get_top(lbox)
            bottom = box.get_bottom(lbox)
            ago = box.get_left(lbox)
            if array.get(pvl1_price, 0) < top
                if box_sv
                    box.set_bgcolor(lbox, t_d)
                if ob_a_sv and close > top
                    if array.get(pvl1_time, 0) != l_a_time
                        l_a_time := array.get(pvl1_time, 0)
                        alert := alert + 'Demand Zone Test @ ' + str.tostring(array.get(pvl1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvh1_price, 0) < bottom
                if m_sv
                    box.set_bgcolor(lbox, u_b)
                    array.push(m_short_boxes, lbox)
                else
                    box.delete(lbox)
                array.remove(long_boxes, i)
                if msb_sv
                    line.delete(array.get(bull_bos_lines, i))
                    array.remove(bull_bos_lines, i)
    if array.size(m_short_boxes) > 0
        for i = array.size(m_short_boxes) - 1 to 0 by 1
            tbox = array.get(m_short_boxes, i)
            top = box.get_top(tbox)
            bottom = box.get_bottom(tbox)
            ago = box.get_left(tbox)
            if array.get(pvh1_price, 0) > bottom 
                box.set_bgcolor(tbox, t_b)
                if bb_a_sv and close < bottom
                    if array.get(pvh1_time, 0) != mh_a_time
                        mh_a_time := array.get(pvh1_time, 0)
                        alert := alert + 'Breakerblock Test Up @ ' + str.tostring(array.get(pvh1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvl1_price, 0) > top
                box.delete(tbox)
                array.remove(m_short_boxes, i)
    if array.size(m_long_boxes) > 0
        for i = array.size(m_long_boxes) - 1 to 0 by 1
            lbox = array.get(m_long_boxes, i)
            top = box.get_top(lbox)
            bottom = box.get_bottom(lbox)
            ago = box.get_left(lbox)
            if array.get(pvl1_price, 0) < top
                box.set_bgcolor(lbox, t_b)
                if bb_a_sv and close > top
                    if array.get(pvl1_time, 0) != ml_a_time
                        ml_a_time := array.get(pvl1_time, 0)
                        alert := alert + 'Breakerblock Test Down @ ' + str.tostring(array.get(pvl1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvh1_price, 0) < bottom
                box.delete(lbox)
                array.remove(m_long_boxes, i)
    if range_sv and (new_ph_2nd or new_pl_2nd) and (array.get(pvh2_price, 0) < array.get(pvh2_price, 1) and array.get(pvl2_price, 0) > array.get(pvl2_price, 1) and array.get(pvh2_price, 0) > array.get(pvl2_price, 1) and array.get(pvl2_price, 0) < array.get(pvh2_price, 1)) and (array.get(pvl2_price, 1) > nz(last_range_h) or na(last_range_l)? true : (array.get(pvh2_price, 1) < last_range_l))
        temp_time := math.min(array.get(pvh2_time, 1), array.get(pvl2_time, 1))
        last_range_h    := array.get(pvh2_price, 1)
        last_range_l    := array.get(pvl2_price, 1)
        temp_pv_0 := log_sv ? math.exp((math.log(last_range_h) + math.log(last_range_l))/2) : (last_range_h + last_range_l)/2
        temp_pv_1 := log_sv ? math.exp((math.log(last_range_h) + math.log(temp_pv_0))/2) : (last_range_h + temp_pv_0)/2
        temp_pv_2 := log_sv ? math.exp((math.log(last_range_l) + math.log(temp_pv_0))/2) : (last_range_l + temp_pv_0)/2
        array.push(range_h_lines, line.new(x1=temp_time, y1=last_range_h, x2=bar_index, y2=last_range_h, color=color.black, width=2, extend=extend.right))
        array.push(range_l_lines, line.new(x1=temp_time, y1=last_range_l, x2=bar_index, y2=last_range_l, color=color.black, width=2, extend=extend.right))
        if range_eq_sv
            array.push(range_m_lines, line.new(x1=temp_time, y1=temp_pv_0, x2=bar_index, y2=temp_pv_0, color=color.gray, width=2, extend=extend.right))
        if range_q_sv
            array.push(range_25_lines, line.new(x1=temp_time, y1=temp_pv_1, x2=bar_index, y2=temp_pv_1, style=line.style_dashed, color=color.gray, width=1, extend=extend.right))
            array.push(range_75_lines, line.new(x1=temp_time, y1=temp_pv_2, x2=bar_index, y2=temp_pv_2, style=line.style_dashed, color=color.gray, width=1, extend=extend.right))
        if r_a_sv
            alert := alert + 'New Range : ' + str.tostring(last_range_h) + ' - ' +  str.tostring(last_range_l) + '. Mean = ' +  str.tostring(temp_pv_0) + '\n'
    if array.size(range_h_lines) > 0
        for i = array.size(range_h_lines) - 1 to 0 by 1
            range_h = array.get(range_h_lines, i)
            top = line.get_y1(range_h)
            range_l = array.get(range_l_lines, i)
            bottom = line.get_y1(range_l)
            temp_time := line.get_x1(range_h)
            if array.get(pvh1_price, 0) > top
                if rt_a_sv and close < top
                    if array.get(pvh1_time, 0) != rh_a_time
                        rh_a_time := array.get(pvh1_time, 0)
                        alert := alert + 'Range High Test @ ' + str.tostring(array.get(pvh1_price, 0)) + ' \n'
            if array.get(pvl1_price, 0) < bottom
                if rt_a_sv and close > bottom
                    if array.get(pvl1_time, 0) != rl_a_time
                        rl_a_time := array.get(pvl1_time, 0)
                        alert := alert + 'Range Low Test @ ' + str.tostring(array.get(pvl1_price, 0)) + ' \n'
            if range_eq_sv
                range_m := array.get(range_m_lines, i)
            if range_q_sv
                range_25 := array.get(range_25_lines, i)
                range_75 := array.get(range_75_lines, i)
            if array.get(pvh1_price, 0) < bottom or array.get(pvl1_price, 0) > top
                line.delete(range_h)
                array.remove(range_h_lines, i)
                line.delete(range_l)
                array.remove(range_l_lines, i)
                if range_eq_sv
                    line.delete(range_m)                
                    array.remove(range_m_lines, i)
                if range_q_sv
                    line.delete(range_25)                
                    array.remove(range_25_lines, i)
                    line.delete(range_75)                
                    array.remove(range_75_lines, i)
                last_range_h    := na
                last_range_l    := na
    if pv2_sv
        if new_ph_2nd
            array.push(la_ph2, label.new(x = array.get(pvh2_time, 0), y = array.get(pvh2_price, 0), xloc = xloc.bar_index, style = label.style_label_down,    color = #770000FF, size = size.tiny))
        if new_pl_2nd
            array.push(la_pl2, label.new(x = array.get(pvl2_time, 0), y = array.get(pvl2_price, 0), xloc = xloc.bar_index, style = label.style_label_up,      color = #007700FF, size = size.tiny))

alert := not na(alert) ? (alert + 'Current price = ' + str.tostring(close) + '\n') : na
exec = not na(alert) ? true : false
if exec==true 
    alert(alert, alert.freq_once_per_bar_close)


if na(volume) and (mp == false)
    runtime.error("No Volume Data. Please Use a Ticker with Volume Data or Switch to Market Profile Calculation.")

if barstate.islast and na(ta.valuewhen(timeframe.change(tf),bar_index,1))
    runtime.error("Profile Timeframe is Too Large. Please Increase Chart Timeframe, or Decrease Profile Timeframe.")

round_to(_round,_to) =>
    math.round(_round/_to)*_to

vol_prof(_tf,_mdr) =>
    tf_change = timeframe.change(_tf)                                                                           //condition to clear arrays and start new calculation
    var main = array.new_float(na)                                                                              //main array
    var float base = na                                                                                         //lowest price in vp
    var float roof = na                                                                                         //highest price in vp
    max_array_dol_range = syminfo.mintick*(_mdr*100)                                                            //maxium number of difference between the base and roof before automatically reducing the granularity(Using Ticks so it will scale with different tickers)
    change_dif = nz(ta.valuewhen(tf_change,bar_index,0) - ta.valuewhen(tf_change,bar_index,1),1)                //determines the # of bars between recalculation blocks
    rng_get = ta.valuewhen(tf_change,ta.highest(high,change_dif) - ta.lowest(low,change_dif),0)                 //difference between high and low of the last block of the timeframe input(I use this to automatically set the granularity for the next block)
    tick_size = rng_get>max_array_dol_range?math.ceil(rng_get/max_array_dol_range)*syminfo.mintick:syminfo.mintick    //if the range is > max allowable difference, it scales accordingly, else, just use mintick
    
    c_hi = round_to(high,tick_size)                         //candle high value rounded to the nearest calculation tick
    c_lo = round_to(low,tick_size)                          //candle low value rounded to the nearest calculation tick
    candle_range = c_hi - c_lo                              //range of high and low value
    candle_index = (candle_range/tick_size)+1               //# of ticks within the range (add 1 because when we append on this index we want to start at 0 so range of 14 means start at 0, go to 14, so 15 total indexes)
    tick_vol = mp?1:math.round(volume/candle_index)         //splits the candle's cumulative volume amongst each candle index to give the distributed volume value. If using market profile, this value is 1
    
    //Start
    if tf_change                        // If new block
        array.clear(main)               //clear the main array
        base := c_lo                    //set the lowest vp value to == the low adjusted for tick size
        roof := c_hi                    //set highest vp value to == the high adjusted for tick size
        for i = 0 to candle_index-1     //and for every index in the current candle(since this is the first candle of the new block)
            array.push(main,tick_vol)   //push the tick volume into each array index for the amount of 
    //Expand Down
    down_dif = math.abs((base - c_lo)/tick_size)    //determine the difference (in ticks) between the candle low and the lowest vp value
    if c_lo < base                                  //if the candle low is less than the lowest vp value, we need to add indexes to the main array downwards 
        for i = 1 to down_dif                       // for 1 to down dif
            array.unshift(main,0)                   // add a 0 value to the front of the array
        base := c_lo                                // and the lowest vp value now == the candle low adjusted for tick size
    z_point = math.abs((base - c_lo)/tick_size)     //same as down_dif but by defining the variable here we get the info after the above loop has run (ex. on a candle when the loop runs down_dif might equal 3, but z_point will equal 0)
        
    //Expand Up
    up_dif = math.abs((roof - c_hi)/tick_size)      //exactly the same as above, just upwards instead of downwards
    if c_hi > roof                                  //
        for i = 1 to up_dif                         //
            array.push(main,0)                      //
        roof := c_hi                                //
    //h_point = math.abs((roof - c_hi)/tick_size)     //since everything starts from the bottom up, this variable is redundant and is not actually used anywhere. Was used in development to confirm the values are being properly compiled.
        
    //Input Values
    for i = 0 to array.size(main)                                   // for every index in our main array
        if (i >= z_point) and (i <= (z_point + candle_index)-1)     // if the index is inside of our candle's index
            v = array.get(main,int(i))                              // get the main array's index value
            array.set(main,int(i),v + tick_vol)                     // and add the tick volume to it

    max_index = math.round(math.avg(array.indexof(main,array.max(main)),array.lastindexof(main,array.max(main)))) // determine the last occurance and first occurance of the max value in our array, and give us the average index of teh 2.
    poc = base + (tick_size*max_index) //start at base add a tick for every index to the max index. this one reads pretty well. ^^Cont. Max value == POC index, but flat tops occur alot in this calcualtion method,due to the data available, this makes it determine 1 value vs only the first one it comes across.
    //Value Zones
    max_vol = array.sum(main)*vap                                                   //This is how much volume is in the value zone
    vol_count = max_index >=0?array.get(main, max_index):0.0                        //counter variable to count how much volume we have currently have accumulated, not declaring "var" resets this on every calculation, but in the loop below it will change the value of this while in the for loop but onyl give us 1 number in the end, and then recalc next tick.
    up_count = max_index                                                            //counter variable same as above, set to max index because we want to start at our poc and count the volume expanding outwards to determine the value zone.
    down_count = max_index                                                          //counter variable ^^
    for x = 0 to array.size(main)-1                                                 // for every index in out main array - 1
        if vol_count >= max_vol                                                     // if our volume counter is >= the volume in the value zone, we're done with this calculation, this loop repeats until this is true.
            break                                                                   
        uppervol = up_count<array.size(main)-1?array.get(main, up_count + 1):na     // grabs volume data (aka,  main array value) 1 above poc
        lowervol = down_count>0?array.get(main, down_count - 1):na                  // grabs ^same^ 1 below poc
        if ((uppervol >= lowervol) and not na(uppervol)) or na(lowervol)            // code reads well here
            vol_count += uppervol                                                   // add volume to volume count
            up_count += 1                                                           // tick our up counter + 1
        else                                                                        
            vol_count += lowervol                                                   // same  as above but down
            down_count -= 1                                                         //rinse and repeat
    val = base + (tick_size*down_count)                 //After the loop above, down_count == value low index
    vah = base + (tick_size*up_count)                   //<^These do the same thing as determining poc, up_count == value high index
    pd_vah = ta.valuewhen(tf_change,vah[1],0)           //find the block change, and take the last bar's value
    pd_val = ta.valuewhen(tf_change,val[1],0)           //
    pd_poc = ta.valuewhen(tf_change,poc[1],0)           //
    [poc,vah,val,pd_poc,pd_vah,pd_val,main,base,tick_size,up_count,down_count,max_index,roof]

[poc,vah,val,pd_poc,pd_vah,pd_val,main,base,tick_size,up_count,down_count,mv,roof] = vol_prof(tf,mdr)

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

day_len = ta.valuewhen(timeframe.change(tf),bar_index,0)-ta.valuewhen(timeframe.change(tf),bar_index,1)

var profile = array.new_line(na)    
if array.size(profile) > 0
    for i = 0 to array.size(profile) - 1
        line.delete(array.get(profile, i))
        if i == (array.size(profile) - 1)
            array.clear(profile)
var box_profile = array.new_box(na) 
if array.size(box_profile) > 0
    for i = 0 to array.size(box_profile) - 1
        box.delete(array.get(box_profile, i))
        if i == (array.size(box_profile) - 1)
            array.clear(box_profile)

min_array = array.copy(main)
if array.size(min_array) > 0
    for i = array.size(min_array)-1 to 0
        if array.get(min_array,i) == 0
            array.remove(min_array,i)

prof_color(_num) =>
    _num==mv?poc_color:
     (_num==up_count or _num==down_count)?var_color:
     array.get(main,_num) == array.min(min_array)?sp_color:
     (_num>up_count or _num<down_count)?ov_color:
     vaz_color
     
bi_nd = ta.valuewhen(timeframe.change(tf),bar_index,0)
if barstate.islast
    if array.size(main) > 0
        for i = 0 to array.size(main) - 1
            scale = disp_size/array.max(main)
            scaled = math.round(array.get(main,i)*scale)
            if ((i>up_count) or (i<down_count)) or (array.size(box_profile) >= 450)
                array.push(profile,line.new(bar_index+prof_offset,base+(i*tick_size),(bar_index+scaled)+prof_offset,base+(i*tick_size), color = prof_color(i), style = (i<down_count or i>up_count?line.style_dotted:line.style_solid)))
            else
                array.push(box_profile,box.new(bar_index+prof_offset,base+(i*tick_size),(bar_index+scaled)+prof_offset,base+(i*tick_size), border_color = prof_color(i), border_style = (i<down_count or i>up_count?line.style_dotted:line.style_solid), border_width = 1))

var pd_lines = array.new_line(na)
if timeframe.change(tf) and hist
    array.push(pd_lines,line.new(bar_index-day_len,pd_poc,bar_index-1,pd_poc,color = poc_color, width = 2))
    array.push(pd_lines,line.new(bar_index-day_len,pd_vah,bar_index-1,pd_vah,color = var_color, width = 2))
    array.push(pd_lines,line.new(bar_index-day_len,pd_val,bar_index-1,pd_val,color = var_color, width = 2))
if array.size(pd_lines) > 90
    line.delete(array.get(pd_lines,0))
    array.remove(pd_lines,0)
if extend_day
    d_poc = line.new(bi_nd,poc,bar_index,poc,color = poc_color, width = 2)
    d_vah = line.new(bi_nd,vah,bar_index,vah,color = var_color, width = 2)
    d_val = line.new(bi_nd,val,bar_index,val,color = var_color, width = 2)
    line.delete(d_poc[1])
    line.delete(d_vah[1])
    line.delete(d_val[1])

alertcondition(ta.crossover(close,poc), "Cross-Over Point of Control")
alertcondition(ta.crossunder(close,poc), "Cross-Under Point of Control")
alertcondition(ta.crossover(close,vah), "Cross-Over Value High")
alertcondition(ta.crossunder(close,vah), "Cross-Under Value High")
alertcondition(ta.crossover(close,val), "Cross-Over Value Low")
alertcondition(ta.crossunder(close,val),"Cross-Under Value Low")

//---------------------------- Constants ------------------------------

var DEFAULT_LINE_WIDTH = 1
var DEFAULT_TAIL_STYLE = line.style_dotted
var DEFAULT_LABEL_SIZE = size.small
var DEFAULT_LABEL_STYLE = label.style_none

//------------------------------ Inputs -------------------------------

var i_isDailyEnabled = input.bool(defval=true, title='Daily', group='Current Opens', inline='Daily')
var i_dailyColor = input.color(defval=color.green, title='', group='Current Opens', inline='Daily')
var i_isWeeklyEnabled = input.bool(defval=true, title='Weekly', group='Current Opens', inline='Weekly')
var i_weeklyColor = input.color(defval=color.orange, title='', group='Current Opens', inline='Weekly')
var i_isMonthlyEnabled = input.bool(defval=true, title='Monthly', group='Current Opens', inline='Monthly')
var i_monthlyColor = input.color(defval=color.red, title='', group='Current Opens', inline='Monthly')
var i_isYearlyEnabled = input.bool(defval=false, title='Yearly', group='Current Opens', inline='Yearly')
var i_yearlyColor = input.color(defval=color.blue, title='', group='Current Opens', inline='Yearly')

var i_isPDailyEnabled = input.bool(defval=true, title='Daily', group='Previous Opens', inline='Daily')
var i_pdailyColor = input.color(defval=color.green, title='', group='Previous Opens', inline='Daily')
var i_isPWeeklyEnabled = input.bool(defval=true, title='Weekly', group='Previous Opens', inline='Weekly')
var i_pweeklyColor = input.color(defval=color.orange, title='', group='Previous Opens', inline='Weekly')
var i_isPMonthlyEnabled = input.bool(defval=true, title='Monthly', group='Previous Opens', inline='Monthly')
var i_pmonthlyColor = input.color(defval=color.red, title='', group='Previous Opens', inline='Monthly')
var i_isPYearlyEnabled = input.bool(defval=false, title='Yearly', group='Previous Opens', inline='Yearly')
var i_pyearlyColor = input.color(defval=color.blue, title='', group='Previous Opens', inline='Yearly')

var i_isMondayHighEnabled = input.bool(defval=true, title='Monday High', group='Current High/Low', inline='Monday High')
var i_mondayHighColor = input.color(defval=color.lime, title='', group='Current High/Low', inline='Monday High')
var i_isMondayLowEnabled = input.bool(defval=true, title='MondayLow', group='Current High/Low', inline='Monday Low')
var i_mondayLowColor = input.color(defval=color.lime, title='', group='Current High/Low', inline='Monday Low')
var i_isDailyHEnabled = input.bool(defval=true, title='Daily High', group='Current High/Low', inline='Daily High')
var i_dailyHColor = input.color(defval=color.green, title='', group='Current High/Low', inline='Daily High')
var i_isDailyLEnabled = input.bool(defval=true, title='Daily Low', group='Current High/Low', inline='Daily Low')
var i_dailyLColor = input.color(defval=color.green, title='', group='Current High/Low', inline='Daily Low')
var i_isWeeklyHEnabled = input.bool(defval=true, title='Weekly High', group='Current High/Low', inline='Weekly High')
var i_weeklyHColor = input.color(defval=color.orange, title='', group='Current High/Low', inline='Weekly High')
var i_isWeeklyLEnabled = input.bool(defval=true, title='Weekly Low', group='Current High/Low', inline='Weekly Low')
var i_weeklyLColor = input.color(defval=color.orange, title='', group='Current High/Low', inline='Weekly Low')
var i_isMonthlyHEnabled = input.bool(defval=true, title='Monthly High', group='Current High/Low', inline='Monthly High')
var i_monthlyHColor = input.color(defval=color.red, title='', group='Current High/Low', inline='Monthly High')
var i_isMonthlyLEnabled = input.bool(defval=true, title='Monthly Low', group='Current High/Low', inline='Monthly Low')
var i_monthlyLColor = input.color(defval=color.red, title='', group='Current High/Low', inline='Monthly Low')
var i_isYearlyHEnabled = input.bool(defval=false, title='Yearly High', group='Current High/Low', inline='Yearly High')
var i_yearlyHColor = input.color(defval=color.orange, title='', group='Current High/Low', inline='Yearly High')
var i_isYearlyLEnabled = input.bool(defval=false, title='Yearly Low', group='Current High/Low', inline='Yearly Low')
var i_yearlyLColor = input.color(defval=color.orange, title='', group='Current High/Low', inline='Yearly Low')

var i_isPDailyHEnabled = input.bool(defval=false, title='Daily High', group='Previous High/Low', inline='Daily High')
var i_pdailyHColor = input.color(defval=color.green, title='', group='Previous High/Low', inline='Daily High')
var i_isPDailyLEnabled = input.bool(defval=false, title='Daily Low', group='Previous High/Low', inline='Daily Low')
var i_pdailyLColor = input.color(defval=color.green, title='', group='Previous High/Low', inline='Daily Low')
var i_isPWeeklyHEnabled = input.bool(defval=true, title='Weekly High', group='Previous High/Low', inline='Weekly High')
var i_pweeklyHColor = input.color(defval=color.orange, title='', group='Previous High/Low', inline='Weekly High')
var i_isPWeeklyLEnabled = input.bool(defval=true, title='Weekly Low', group='Previous High/Low', inline='Weekly Low')
var i_pweeklyLColor = input.color(defval=color.orange, title='', group='Previous High/Low', inline='Weekly Low')
var i_isPMonthlyHEnabled = input.bool(defval=true, title='Monthly High', group='Previous High/Low', inline='Monthly High')
var i_pmonthlyHColor = input.color(defval=color.red, title='', group='Previous High/Low', inline='Monthly High')
var i_isPMonthlyLEnabled = input.bool(defval=true, title='Monthly Low', group='Previous High/Low', inline='Monthly Low')
var i_pmonthlyLColor = input.color(defval=color.red, title='', group='Previous High/Low', inline='Monthly Low')
var i_isPYearlyHEnabled = input.bool(defval=false, title='Yearly High', group='Previous High/Low', inline='Yearly High')
var i_pyearlyHColor = input.color(defval=color.orange, title='', group='Previous High/Low', inline='Yearly High')
var i_isPYearlyLEnabled = input.bool(defval=false, title='Yearly Low', group='Previous High/Low', inline='Yearly Low')
var i_pyearlyLColor = input.color(defval=color.orange, title='', group='Previous High/Low', inline='Yearly Low')

var i_isTailsEnabled = input.bool(defval=true, title='Show Tails', group='Settings')
var i_projectionOffset = input.int(defval=5, title='Offset', group='Settings', minval=1)

var i_doStr = input.string(defval="DO", title="Daily Opening Label", group="Label Captions")
var i_woStr = input.string(defval="WO", title="Weekly Opening Label", group="Label Captions")
var i_moStr = input.string(defval="MO", title="Monthly Opening Label", group="Label Captions")
var i_yoStr = input.string(defval="YO", title="Yearly Opening Label", group="Label Captions")

var i_pdoStr = input.string(defval="PDO", title="Previous Daily Opening Label", group="Label Captions")
var i_pwoStr = input.string(defval="PWO", title="Previous Weekly Opening Label", group="Label Captions")
var i_pmoStr = input.string(defval="PMO", title="Previous Monthly Opening Label", group="Label Captions")
var i_pyoStr = input.string(defval="PYO", title="Previous Yearly Opening Label", group="Label Captions")

var i_dhStr = input.string(defval="DH", title="Daily High Label", group="Label Captions")
var i_dlStr = input.string(defval="DL", title="Daily Low Label", group="Label Captions")
var i_whStr = input.string(defval="WH", title="Weekly High Label", group="Label Captions")
var i_wlStr = input.string(defval="WL", title="Weekly Low Label", group="Label Captions")
var i_mhStr = input.string(defval="MH", title="Monthly High Label", group="Label Captions")
var i_mlStr = input.string(defval="ML", title="Monthly Low Label", group="Label Captions")
var i_yhStr = input.string(defval="YH", title="Yearly High Label", group="Label Captions")
var i_ylStr = input.string(defval="YL", title="Yearly High Label", group="Label Captions")

var i_pdhStr = input.string(defval="PDH", title="Previous Daily High Label", group="Label Captions")
var i_pdlStr = input.string(defval="PDL", title="Previous Daily Low Label", group="Label Captions")
var i_pwhStr = input.string(defval="PWH", title="Previous Weekly High Label", group="Label Captions")
var i_pwlStr = input.string(defval="PWL", title="Previous Weekly Low Label", group="Label Captions")
var i_pmhStr = input.string(defval="PMH", title="Previous Monthly High Label", group="Label Captions")
var i_pmlStr = input.string(defval="PML", title="Previous Monthly Low Label", group="Label Captions")
var i_pyhStr = input.string(defval="PYH", title="Previous Yearly High Label", group="Label Captions")
var i_pylStr = input.string(defval="PYL", title="Previous Yearly Low Label", group="Label Captions")


var i_monhStr = input.string(defval="MH", title="Monday High Label", group="Label Captions")
var i_monlStr = input.string(defval="ML", title="Monday Low Label", group="Label Captions")

//----------------------------- Securities -----------------------------

[dailyTime, dailyOpen, dailyHigh, dailyLow] = request.security(syminfo.tickerid, timeframe.isintraday ? '1440' : 'D', [time, open, high, low], lookahead=barmerge.lookahead_off)
[weeklyTime, weeklyOpen, weeklyHigh, weeklyLow] = request.security(syminfo.tickerid, 'W', [time, open, high, low], lookahead=barmerge.lookahead_off)
[monthlyTime, monthlyOpen, monthlyHigh, monthlyLow] = request.security(syminfo.tickerid, 'M', [time, open, high, low], lookahead=barmerge.lookahead_off)
[yearlyTime, yearlyOpen, yearlyHigh, yearlyLow] = request.security(syminfo.tickerid, '12M', [time, open, high, low], lookahead=barmerge.lookahead_off)

[pdailyTime, pdailyOpen, pdailyHigh, pdailyLow] = request.security(syminfo.tickerid, timeframe.isintraday ? '1440' : 'D', [time[1], open[1], high[1], low[1]], lookahead=barmerge.lookahead_off)
[pweeklyTime, pweeklyOpen, pweeklyHigh, pweeklyLow] = request.security(syminfo.tickerid, 'W', [time[1], open[1], high[1], low[1]], lookahead=barmerge.lookahead_off)
[pmonthlyTime, pmonthlyOpen, pmonthlyHigh, pmonthlyLow] = request.security(syminfo.tickerid, 'M', [time[1], open[1], high[1], low[1]], lookahead=barmerge.lookahead_off)
[pyearlyTime, pyearlyOpen, pyearlyHigh, pyearlyLow] = request.security(syminfo.tickerid, '12M', [time[1], open[1], high[1], low[1]], lookahead=barmerge.lookahead_off)

day = dayofweek(timenow)
mondayOffset= day == dayofweek.monday ? 0 : day == dayofweek.tuesday ? 1 : day == dayofweek.wednesday ? 2 : day == dayofweek.thursday ? 3 : day == dayofweek.friday ? 4 : day == dayofweek.saturday ? 5 : 6
[mondayTime, mondayLow, mondayHigh] = request.security(syminfo.tickerid, timeframe.isintraday ? '1440' : 'D', [time[mondayOffset], low[mondayOffset], high[mondayOffset]], lookahead=barmerge.lookahead_off)

//--------------------------- Function helpers -------------------------

f_drawLine(_x1, _x2, _y, _color, _width) =>
    var _line = line.new(x1=_x1, x2=_x2, y1=_y, y2=_y, color=_color, width=_width, xloc=xloc.bar_time)

    line.set_xy1(_line, _x1, _y)
    line.set_xy2(_line, _x2, _y)

f_drawLabel(_x, _y, _text, _textcolor, _style, _size) =>
    var _label = label.new(x=_x, y=_y, text=_text, textcolor=_textcolor, style=_style, size=_size, xloc=xloc.bar_time)

    label.set_xy(_label, _x, _y)

f_drawTail(_x1, _x2, _y, _color, _style, _width) =>
    var _line = line.new(x1=_x1, x2=_x2, y1=_y, y2=_y, color=_color, style=_style, width=_width, extend=extend.left, xloc=xloc.bar_time)

    line.set_xy1(_line, _x1, _y)
    line.set_xy2(_line, _x2, _y)

f_getRightOffset(_margin) =>
    _padding = 4
    _bar = math.min(time - time[1], time[1] - time[2])
    time + _bar * (i_projectionOffset + _margin * _padding)

f_drawCompleteLine(v_margin, v_open, v_time, v_color, v_str) => 
    c_rightOffset = f_getRightOffset(v_margin)

    if i_isTailsEnabled
        f_drawTail(time, c_rightOffset, v_open, v_color, DEFAULT_TAIL_STYLE, DEFAULT_LINE_WIDTH)

    f_drawLine(time, c_rightOffset, v_open, v_color, DEFAULT_LINE_WIDTH)
    f_drawLine(v_time, time, v_open, v_color, DEFAULT_LINE_WIDTH)
    f_drawLabel(c_rightOffset, v_open, v_str, v_color, DEFAULT_LABEL_STYLE, DEFAULT_LABEL_SIZE)

//------------------------------- Daily Weekly Monthly --------------------------------

var canShowDaily = timeframe.isintraday
var canShowWeekly = (timeframe.isintraday or timeframe.isdaily)
var canShowMonthly = (timeframe.isintraday or timeframe.isdaily or timeframe.isweekly)
var canShowYearly = (timeframe.isintraday or timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly and timeframe.multiplier < 12)

wo = weeklyOpen
wt = weeklyTime
mo = monthlyOpen
mt = monthlyTime
yo = yearlyOpen
yt = yearlyTime

// Markets with extended sessions (e.g. TSLA) are available for intradays charts only
// As the yearly, monthly and weekly data come respectively from the 12M, 1M, 1W timeframes, extended hours are excluded
// When user chart option "ext" is toggled on, opens' price and time don't match
// In such case, we visually want to use the extended hour open and time

var float extWeeklyOpen = na
var float extMonthlyOpen = na
var float extYearlyOpen = na
var float extWeeklyHigh = na
var float extMonthlyHigh = na
var float extYearlyHigh = na
var float extWeeklyLow = na
var float extMonthlyLow = na
var float extYearlyLow = na
var int extWeeklyTime = na
var int extMonthlyTime = na
var int extYearlyTime = na

if timeframe.isintraday and syminfo.session == session.extended
    if weekofyear != weekofyear[1]
        extWeeklyOpen := dailyOpen
        extWeeklyHigh := dailyHigh
        extWeeklyLow := dailyLow
        extWeeklyTime := dailyTime
        extWeeklyTime
    if month != month[1]
        extMonthlyOpen := dailyOpen
        extMonthlyHigh := dailyHigh
        extMonthlyLow := dailyLow
        extMonthlyTime := dailyTime
        extMonthlyTime
    if year != year[1]
        extYearlyOpen := dailyOpen
        extYearlyHigh := dailyHigh
        extYearlyLow := dailyLow
        extYearlyTime := dailyTime
        extYearlyTime

    wo := extWeeklyOpen
    wt := extWeeklyTime
    mo := extMonthlyOpen
    mt := extMonthlyTime
    yo := extYearlyOpen
    yt := extYearlyTime
    yt

// On the weekly timeframe, pinescript draws lines from the first weekly candle whose start date belongs to a given month/year
// E.g. if the first weekly candle of the month start date is the 3rd of Feb, then the monthly open line is drawn from this candle
// In such case, we visually want it to be anchored on the previous week which contains the 1st Feb

var int weeklyTimeOnYearChange = na
var int x1YearlyAnchor = na
var int weeklyTimeOnMonthChange = na
var int x1MonthlyAnchor = na

if timeframe.isweekly
    if yearlyTime != yearlyTime[1]
        weeklyTimeOnYearChange := weeklyTime
        x1YearlyAnchor := weeklyTime[1]
        x1YearlyAnchor
    if monthlyTime != monthlyTime[1]
        weeklyTimeOnMonthChange := weeklyTime
        x1MonthlyAnchor := weeklyTime[1]
        x1MonthlyAnchor

    // Theorically we would adjust the position if the weekly start date is different than the 1st
    // Which pratically result actually of the first day of the month/year considering holidays
    if dayofmonth(weeklyTimeOnYearChange) != dayofmonth(yearlyTime)
        yt := x1YearlyAnchor
        yt
    if dayofmonth(weeklyTimeOnMonthChange) != dayofmonth(monthlyTime)
        mt := x1MonthlyAnchor
        mt

//------------------------------ Plotting ------------------------------

if barstate.islast
    //
    // Yearly
    //
    if canShowYearly
        _margin = 0
        if i_isYearlyEnabled
            f_drawCompleteLine(_margin, yearlyOpen, yearlyTime, i_yearlyColor, i_yoStr)
        if i_isPYearlyEnabled
            f_drawCompleteLine(_margin+1, pyearlyOpen, pyearlyTime, i_pyearlyColor, i_pyoStr)
        if i_isYearlyHEnabled
            f_drawCompleteLine(_margin, yearlyHigh, yearlyTime, i_yearlyHColor, i_yhStr)
        if i_isPYearlyHEnabled
            f_drawCompleteLine(_margin+1, pyearlyHigh, pyearlyTime, i_pyearlyHColor, i_pyhStr)
        if i_isYearlyLEnabled
            f_drawCompleteLine(_margin, yearlyLow, yearlyTime, i_yearlyLColor, i_ylStr)
        if i_isPYearlyLEnabled
            f_drawCompleteLine(_margin+1, pyearlyLow, pyearlyTime, i_pyearlyLColor, i_pylStr)

    //
    // Monthly
    //
    if canShowMonthly
        _margin = 2
        if i_isMonthlyEnabled
            f_drawCompleteLine(_margin, monthlyOpen, monthlyTime, i_monthlyColor, i_moStr)
        if i_isPMonthlyEnabled
            f_drawCompleteLine(_margin+1, pmonthlyOpen, pmonthlyTime, i_pmonthlyColor, i_pmoStr)
        if i_isMonthlyHEnabled
            f_drawCompleteLine(_margin, monthlyHigh, monthlyTime, i_monthlyHColor, i_mhStr)
        if i_isPMonthlyHEnabled
            f_drawCompleteLine(_margin+1, pmonthlyHigh, pmonthlyTime, i_pmonthlyHColor, i_pmhStr)
        if i_isMonthlyLEnabled
            f_drawCompleteLine(_margin, monthlyLow, monthlyTime, i_monthlyLColor, i_mlStr)
        if i_isPMonthlyLEnabled
            f_drawCompleteLine(_margin+1, pmonthlyLow, pmonthlyTime, i_pmonthlyLColor, i_pmlStr)

    //
    // Weekly
    //
    if canShowWeekly
        _margin = 4
        if i_isWeeklyEnabled
            f_drawCompleteLine(_margin, weeklyOpen, weeklyTime, i_weeklyColor, i_woStr)
        if i_isPWeeklyEnabled
            f_drawCompleteLine(_margin+1, pweeklyOpen, pweeklyTime, i_pweeklyColor, i_pwoStr)
        if i_isWeeklyHEnabled
            f_drawCompleteLine(_margin, weeklyHigh, weeklyTime, i_weeklyHColor, i_whStr)
        if i_isPWeeklyHEnabled
            f_drawCompleteLine(_margin+1, pweeklyHigh, pweeklyTime, i_pweeklyHColor, i_pwhStr)
        if i_isWeeklyLEnabled
            f_drawCompleteLine(_margin, weeklyLow, weeklyTime, i_weeklyLColor, i_wlStr)
        if i_isPWeeklyLEnabled
            f_drawCompleteLine(_margin+1, pweeklyLow, pweeklyTime, i_pweeklyLColor, i_pwlStr)
        if i_isMondayLowEnabled
            f_drawCompleteLine(_margin+1, mondayLow, mondayTime, i_mondayLowColor, i_monlStr)
        if i_isMondayHighEnabled
            f_drawCompleteLine(_margin+1, mondayHigh, mondayTime, i_mondayHighColor, i_monhStr)

    //
    // Daily
    //
    if canShowDaily
        _margin = 6
        if i_isDailyEnabled
            f_drawCompleteLine(_margin, dailyOpen, dailyTime, i_dailyColor, i_doStr)
        if i_isPDailyEnabled
            f_drawCompleteLine(_margin+1, pdailyOpen,pdailyTime, i_pdailyColor, i_pdoStr)
        if i_isDailyHEnabled
            f_drawCompleteLine(_margin, dailyHigh, dailyTime, i_dailyHColor, i_dhStr)
        if i_isPDailyHEnabled
            f_drawCompleteLine(_margin+1, pdailyHigh, pdailyTime, i_pdailyHColor, i_pdhStr)
        if i_isDailyLEnabled
            f_drawCompleteLine(_margin, dailyLow, dailyTime, i_dailyLColor, i_dlStr)
        if i_isPDailyLEnabled
            f_drawCompleteLine(_margin+1, pdailyLow, pdailyTime, i_pdailyLColor, i_pdlStr)
