//Combined version of 
//https://www.tradingview.com/v/zSDlR0YP/
//https://www.tradingview.com/v/WWqoUu7e/
//
//@version=5
indicator(title='OB+PVP+Weeknd', overlay=true, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 5000)

bool        pv2_sv          = input.bool        (false,                          title='Plot 2nd order pivots')
bool        msb_sv          = input.bool        (true,                           title='Plot MSB lines')
bool        box_sv          = input.bool        (true,                           title='Plot Orderblocks')
bool        m_sv            = input.bool        (false,                          title='Plot Breakerblocks')
bool        range_sv        = input.bool        (true,                           title='Plot Range')
bool        range_eq_sv     = input.bool        (true,                           title='Plot Range 0.5 Line')
bool        range_q_sv      = input.bool        (true,                           title='Plot Range 0.25 and 0.75 Lines')
bool        log_sv          = input.bool        (false,                          title='Use Log Scale')
bool        msb_a_sv        = input.bool        (false,                          title='Alert MSB')
bool        ob_a_sv         = input.bool        (false,                          title='Alert Orderblock test')
bool        bb_a_sv         = input.bool        (false,                          title='Alert Breakerblock test')
bool        r_a_sv          = input.bool        (false,                          title='Alert New Range')
bool        rt_a_sv         = input.bool        (false,                          title='Alert Range test')
color       u_s             = input.color       (color.new(#089981, 70),         title='Untested Supply Color')
color       t_s             = input.color       (color.new(#b2b5be, 70),         title='Tested Supply Color')
color       u_d             = input.color       (color.new(#f23645, 70),         title='Untested Demand Color')
color       t_d             = input.color       (color.new(#b2b5be, 70),         title='Tested Demand Color')
color       u_b             = input.color       (color.new(#ff9800, 70),         title='Untested Breaker Color')
color       t_b             = input.color       (color.new(#b2b5be, 70),         title='Tested Breaker Color')

var float[] pvh1_price      = array.new_float   (30, na)            // high
var int[]   pvh1_time       = array.new_int     (30, na)
var float[] pvl1_price      = array.new_float   (30, na)            // low
var int[]   pvl1_time       = array.new_int     (30, na)
var float[] pvh2_price      = array.new_float   (10, na)            // higher high
var int[]   pvh2_time       = array.new_int     (10, na)
var float[] pvl2_price      = array.new_float   (10, na)            // lower low
var int[]   pvl2_time       = array.new_int     (10, na)
var float   htcmrll_price   = na                                    // high that created most recent ll
var int     htcmrll_time    = na
var float   ltcmrhh_price   = na                                    // low that created most recent hh
var int     ltcmrhh_time    = na
var box[]   long_boxes      = array.new_box()                       // orderblocks
var box[]   short_boxes     = array.new_box()
var box[]   m_long_boxes    = array.new_box()                       // breakerblocks
var box[]   m_short_boxes   = array.new_box()
var line[]  bull_bos_lines  = array.new_line()                      // MSB lines
var line[]  bear_bos_lines  = array.new_line()
var line[]  range_h_lines   = array.new_line()                      // Range lines
var line[]  range_25_lines  = array.new_line()
var line[]  range_m_lines   = array.new_line()
var line[]  range_75_lines  = array.new_line()
var line[]  range_l_lines   = array.new_line()
var label[] la_ph2          = array.new_label()                     // 2nd order pivots
var label[] la_pl2          = array.new_label()
var float   temp_pv_0       = na
var float   temp_pv_1       = na
var float   temp_pv_2       = na
var int     temp_time       = na
var float   last_range_h    = na
var float   last_range_l    = na
var line    range_m         = na
var line    range_25        = na
var line    range_75        = na
var float   box_top         = na
var float   box_bottom      = na
var int     h_a_time        = 0
var int     l_a_time        = 0
var int     mh_a_time       = 0
var int     ml_a_time       = 0
var int     rh_a_time       = 0
var int     rl_a_time       = 0
bool        pvh             = high < high[1] and high[1] > high[2]
bool        pvl             = low > low[1] and low[1] < low[2]
int         pv1_time        = bar_index[1]
float       pv1_high        = high[1]
float       pv1_low         = low[1]
bool        new_ph_2nd      = false
bool        new_pl_2nd      = false
string      alert           = na

multiplier = input.float(2.6, minval=0, maxval=10, step=0.02, group = "Weekend")

day_clr = dayofweek < 2 or dayofweek > 6 ? color.new(#9598a1, 75) : color.new(#9598a1, 100)
//plot(((high / low) * ohlc4) * (1 + multiplier / 100), style=plot.style_areabr, color=day_clr)
plot( ((low / high) * ohlc4) * (1 - multiplier / 100), style=plot.style_areabr, color=day_clr)

tf = input.timeframe("D", title = "Timeframe", inline = "0", group = "PROFILE SETTINGS")
mdr = input.float(4, minval = 1,maxval = 4,title = "Sensitivity ", inline = "1", group = "PROFILE SETTINGS", tooltip = "Higher = More Granular\nLower = Less Granular")
vap = input.float(70, title = "Value Area %", inline = "1_1", group = "PROFILE SETTINGS")/100
mp = input.bool(false, title = "Calculate As Market Profile", inline = "2", group = "PROFILE SETTINGS", tooltip = "Calculations will distribue a 1 instead of the candle's volume.")
disp_size = input.int(-30, minval = -500,maxval = 500,title  = "Display Size   ", inline = "3", group = "DISPLAY SETTINGS", tooltip = "The entire range of your profile will scale to fit inside this range.\nNotes:\n-This value is # bars away from your profile's axis.\n-The larger this value is, the more granular your (horizontal) view will be. This does not change the Profiles' value; because of this, sometimes the POC looks tied with other values widely different. The POC CAN be tied to values close to it, but if the value is far away it is likely to just be a visual constraint.\n-This Value CAN be negative")
prof_offset = input.int(40, minval = -500,maxval = 500, title  = "Display Offset", inline = "4", group = "DISPLAY SETTINGS", tooltip = "Offset your profile's axis (Left/Right) to customize your display to fit your style.\nNotes:\n-Zero = Current Bar\n-This Value CAN be negative")
extend_day = input.bool(true, title = "Display Current POC/VAH/VAL", inline = "5", group = "Additional Data Displays")
hist = input.bool(true, title = "Display Historical POC/VAH/VAL", inline = "6", group = "Additional Data Displays")
poc_color = input.color(#ff033e, title = "POC Color", group = "Colors")
var_color = input.color(#00bcd4, title = "Value High/Low Color", group = "Colors")
vaz_color = input.color(color.new(#555555,50), title = "Value Zone Color", group = "Colors")
ov_color = input.color(#555555, title = "Profile Color", group = "Colors")
sp_color = input.color(#801922, title  = "Lowest Value Color", group = "Colors")

if barstate.isconfirmed
    if pvh
        array.pop(pvh1_price)
        array.pop(pvh1_time)
        array.unshift(pvh1_price, pv1_high)
        array.unshift(pvh1_time, pv1_time)
        if array.size(pvh1_price) > 2
            temp_pv_0 := array.get(pvh1_price, 0)
            temp_pv_1 := array.get(pvh1_price, 1)
            temp_pv_2 := array.get(pvh1_price, 2)
            if temp_pv_0 < temp_pv_1 and temp_pv_1 > temp_pv_2
                array.pop(pvh2_price)
                array.pop(pvh2_time)
                array.unshift(pvh2_price, temp_pv_1)
                array.unshift(pvh2_time, array.get(pvh1_time, 1))
                new_ph_2nd := true
                if temp_pv_1 > array.get(pvh2_price, 1)
                    for i = 0 to array.size(pvl2_time) - 1 by 1
                        temp_ltcmrhh_time = array.get(pvl2_time, i)
                        if temp_ltcmrhh_time < array.get(pvh2_time, 0)
                            ltcmrhh_price := array.get(pvl2_price, i)
                            ltcmrhh_time := temp_ltcmrhh_time
                            break
            if temp_pv_0 < ltcmrhh_price
                if msb_sv
                    array.push(bear_bos_lines, line.new(x1=ltcmrhh_time, y1=ltcmrhh_price, x2=bar_index, y2=ltcmrhh_price, color=color.green, width=2))
                box_top := array.get(pvh2_price, 0)
                box_bottom := math.max(low[bar_index - array.get(pvh2_time, 0)], low[bar_index - array.get(pvh2_time, 0) + 1])
                array.push(short_boxes, box.new(left=array.get(pvh2_time, 0), top=box_top, right=bar_index, bottom=box_bottom, bgcolor= box_sv ? u_s : na , border_color=na, extend=extend.right))
                if msb_a_sv
                    alert := alert + 'Bearish MSB @ ' + str.tostring(ltcmrhh_price) + '\n' + 'New Supply Zone : '+ str.tostring(box_top) + ' - ' + str.tostring(box_bottom) + '\n'
                ltcmrhh_price := na
    if pvl
        array.pop(pvl1_price)
        array.pop(pvl1_time)
        array.unshift(pvl1_price, pv1_low)
        array.unshift(pvl1_time, pv1_time)
        if array.size(pvl1_price) > 2
            temp_pv_0 := array.get(pvl1_price, 0)
            temp_pv_1 := array.get(pvl1_price, 1)
            temp_pv_2 := array.get(pvl1_price, 2)
            if temp_pv_0 > temp_pv_1 and temp_pv_1 < temp_pv_2
                array.pop(pvl2_price)
                array.pop(pvl2_time)
                array.unshift(pvl2_price, temp_pv_1)
                array.unshift(pvl2_time, array.get(pvl1_time, 1))
                new_pl_2nd := true
                if temp_pv_1 < array.get(pvl2_price, 1)
                    for i = 0 to array.size(pvh2_time) - 1 by 1
                        temp_htcmrll_time = array.get(pvh2_time, i)
                        if temp_htcmrll_time < array.get(pvl2_time, 0)
                            htcmrll_price := array.get(pvh2_price, i)
                            htcmrll_time := temp_htcmrll_time
                            break
            if temp_pv_0 > htcmrll_price
                if msb_sv
                    array.push(bull_bos_lines, line.new(x1=htcmrll_time, y1=htcmrll_price, x2=bar_index, y2=htcmrll_price, color=color.red, width=2))
                box_top := math.min(high[bar_index - array.get(pvl2_time, 0)], high[bar_index - array.get(pvl2_time, 0) + 1])
                box_bottom := array.get(pvl2_price, 0)
                array.push(long_boxes, box.new(left=array.get(pvl2_time, 0), top=box_top, right=bar_index, bottom=box_bottom, bgcolor= box_sv ? u_d : na, border_color=na, extend=extend.right))
                if msb_a_sv
                    alert := alert + 'Bullish MSB @ ' + str.tostring(htcmrll_price) + '\n' + 'New Demand Zone : '+ str.tostring(box_bottom) + ' - ' + str.tostring(box_top) + '\n'
                htcmrll_price := na
    if array.size(short_boxes) > 0
        for i = array.size(short_boxes) - 1 to 0 by 1
            tbox = array.get(short_boxes, i)
            top = box.get_top(tbox)
            bottom = box.get_bottom(tbox)
            ago = box.get_left(tbox)
            if array.get(pvh1_price, 0) > bottom 
                if box_sv
                    box.set_bgcolor(tbox, t_s)    
                if ob_a_sv and close < bottom
                    if array.get(pvh1_time, 0) != h_a_time
                        h_a_time := array.get(pvh1_time, 0)
                        alert := alert + 'Supply Zone Test @ ' + str.tostring(array.get(pvh1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvl1_price, 0) > top
                if m_sv
                    box.set_bgcolor(tbox, u_b)
                    array.push(m_long_boxes, tbox)
                else
                    box.delete(tbox)
                array.remove(short_boxes, i)
                if msb_sv    
                    line.delete(array.get(bear_bos_lines, i))
                    array.remove(bear_bos_lines, i)
    if array.size(long_boxes) > 0
        for i = array.size(long_boxes) - 1 to 0 by 1
            lbox = array.get(long_boxes, i)
            top = box.get_top(lbox)
            bottom = box.get_bottom(lbox)
            ago = box.get_left(lbox)
            if array.get(pvl1_price, 0) < top
                if box_sv
                    box.set_bgcolor(lbox, t_d)
                if ob_a_sv and close > top
                    if array.get(pvl1_time, 0) != l_a_time
                        l_a_time := array.get(pvl1_time, 0)
                        alert := alert + 'Demand Zone Test @ ' + str.tostring(array.get(pvl1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvh1_price, 0) < bottom
                if m_sv
                    box.set_bgcolor(lbox, u_b)
                    array.push(m_short_boxes, lbox)
                else
                    box.delete(lbox)
                array.remove(long_boxes, i)
                if msb_sv
                    line.delete(array.get(bull_bos_lines, i))
                    array.remove(bull_bos_lines, i)
    if array.size(m_short_boxes) > 0
        for i = array.size(m_short_boxes) - 1 to 0 by 1
            tbox = array.get(m_short_boxes, i)
            top = box.get_top(tbox)
            bottom = box.get_bottom(tbox)
            ago = box.get_left(tbox)
            if array.get(pvh1_price, 0) > bottom 
                box.set_bgcolor(tbox, t_b)
                if bb_a_sv and close < bottom
                    if array.get(pvh1_time, 0) != mh_a_time
                        mh_a_time := array.get(pvh1_time, 0)
                        alert := alert + 'Breakerblock Test Up @ ' + str.tostring(array.get(pvh1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvl1_price, 0) > top
                box.delete(tbox)
                array.remove(m_short_boxes, i)
    if array.size(m_long_boxes) > 0
        for i = array.size(m_long_boxes) - 1 to 0 by 1
            lbox = array.get(m_long_boxes, i)
            top = box.get_top(lbox)
            bottom = box.get_bottom(lbox)
            ago = box.get_left(lbox)
            if array.get(pvl1_price, 0) < top
                box.set_bgcolor(lbox, t_b)
                if bb_a_sv and close > top
                    if array.get(pvl1_time, 0) != ml_a_time
                        ml_a_time := array.get(pvl1_time, 0)
                        alert := alert + 'Breakerblock Test Down @ ' + str.tostring(array.get(pvl1_price, 0)) + ' (age = ' + str.tostring(bar_index-ago) + ' bars) \n'
            if array.get(pvh1_price, 0) < bottom
                box.delete(lbox)
                array.remove(m_long_boxes, i)
    if range_sv and (new_ph_2nd or new_pl_2nd) and (array.get(pvh2_price, 0) < array.get(pvh2_price, 1) and array.get(pvl2_price, 0) > array.get(pvl2_price, 1) and array.get(pvh2_price, 0) > array.get(pvl2_price, 1) and array.get(pvl2_price, 0) < array.get(pvh2_price, 1)) and (array.get(pvl2_price, 1) > nz(last_range_h) or na(last_range_l)? true : (array.get(pvh2_price, 1) < last_range_l))
        temp_time := math.min(array.get(pvh2_time, 1), array.get(pvl2_time, 1))
        last_range_h    := array.get(pvh2_price, 1)
        last_range_l    := array.get(pvl2_price, 1)
        temp_pv_0 := log_sv ? math.exp((math.log(last_range_h) + math.log(last_range_l))/2) : (last_range_h + last_range_l)/2
        temp_pv_1 := log_sv ? math.exp((math.log(last_range_h) + math.log(temp_pv_0))/2) : (last_range_h + temp_pv_0)/2
        temp_pv_2 := log_sv ? math.exp((math.log(last_range_l) + math.log(temp_pv_0))/2) : (last_range_l + temp_pv_0)/2
        array.push(range_h_lines, line.new(x1=temp_time, y1=last_range_h, x2=bar_index, y2=last_range_h, color=color.black, width=2, extend=extend.right))
        array.push(range_l_lines, line.new(x1=temp_time, y1=last_range_l, x2=bar_index, y2=last_range_l, color=color.black, width=2, extend=extend.right))
        if range_eq_sv
            array.push(range_m_lines, line.new(x1=temp_time, y1=temp_pv_0, x2=bar_index, y2=temp_pv_0, color=color.gray, width=2, extend=extend.right))
        if range_q_sv
            array.push(range_25_lines, line.new(x1=temp_time, y1=temp_pv_1, x2=bar_index, y2=temp_pv_1, style=line.style_dashed, color=color.gray, width=1, extend=extend.right))
            array.push(range_75_lines, line.new(x1=temp_time, y1=temp_pv_2, x2=bar_index, y2=temp_pv_2, style=line.style_dashed, color=color.gray, width=1, extend=extend.right))
        if r_a_sv
            alert := alert + 'New Range : ' + str.tostring(last_range_h) + ' - ' +  str.tostring(last_range_l) + '. Mean = ' +  str.tostring(temp_pv_0) + '\n'
    if array.size(range_h_lines) > 0
        for i = array.size(range_h_lines) - 1 to 0 by 1
            range_h = array.get(range_h_lines, i)
            top = line.get_y1(range_h)
            range_l = array.get(range_l_lines, i)
            bottom = line.get_y1(range_l)
            temp_time := line.get_x1(range_h)
            if array.get(pvh1_price, 0) > top
                if rt_a_sv and close < top
                    if array.get(pvh1_time, 0) != rh_a_time
                        rh_a_time := array.get(pvh1_time, 0)
                        alert := alert + 'Range High Test @ ' + str.tostring(array.get(pvh1_price, 0)) + ' \n'
            if array.get(pvl1_price, 0) < bottom
                if rt_a_sv and close > bottom
                    if array.get(pvl1_time, 0) != rl_a_time
                        rl_a_time := array.get(pvl1_time, 0)
                        alert := alert + 'Range Low Test @ ' + str.tostring(array.get(pvl1_price, 0)) + ' \n'
            if range_eq_sv
                range_m := array.get(range_m_lines, i)
            if range_q_sv
                range_25 := array.get(range_25_lines, i)
                range_75 := array.get(range_75_lines, i)
            if array.get(pvh1_price, 0) < bottom or array.get(pvl1_price, 0) > top
                line.delete(range_h)
                array.remove(range_h_lines, i)
                line.delete(range_l)
                array.remove(range_l_lines, i)
                if range_eq_sv
                    line.delete(range_m)                
                    array.remove(range_m_lines, i)
                if range_q_sv
                    line.delete(range_25)                
                    array.remove(range_25_lines, i)
                    line.delete(range_75)                
                    array.remove(range_75_lines, i)
                last_range_h    := na
                last_range_l    := na
    if pv2_sv
        if new_ph_2nd
            array.push(la_ph2, label.new(x = array.get(pvh2_time, 0), y = array.get(pvh2_price, 0), xloc = xloc.bar_index, style = label.style_label_down,    color = #770000FF, size = size.tiny))
        if new_pl_2nd
            array.push(la_pl2, label.new(x = array.get(pvl2_time, 0), y = array.get(pvl2_price, 0), xloc = xloc.bar_index, style = label.style_label_up,      color = #007700FF, size = size.tiny))

alert := not na(alert) ? (alert + 'Current price = ' + str.tostring(close) + '\n') : na
exec = not na(alert) ? true : false
if exec==true 
    alert(alert, alert.freq_once_per_bar_close)


if na(volume) and (mp == false)
    runtime.error("No Volume Data. Please Use a Ticker with Volume Data or Switch to Market Profile Calculation.")

if barstate.islast and na(ta.valuewhen(timeframe.change(tf),bar_index,1))
    runtime.error("Profile Timeframe is Too Large. Please Increase Chart Timeframe, or Decrease Profile Timeframe.")

round_to(_round,_to) =>
    math.round(_round/_to)*_to

vol_prof(_tf,_mdr) =>
    tf_change = timeframe.change(_tf)                                                                           //condition to clear arrays and start new calculation
    var main = array.new_float(na)                                                                              //main array
    var float base = na                                                                                         //lowest price in vp
    var float roof = na                                                                                         //highest price in vp
    max_array_dol_range = syminfo.mintick*(_mdr*100)                                                            //maxium number of difference between the base and roof before automatically reducing the granularity(Using Ticks so it will scale with different tickers)
    change_dif = nz(ta.valuewhen(tf_change,bar_index,0) - ta.valuewhen(tf_change,bar_index,1),1)                //determines the # of bars between recalculation blocks
    rng_get = ta.valuewhen(tf_change,ta.highest(high,change_dif) - ta.lowest(low,change_dif),0)                 //difference between high and low of the last block of the timeframe input(I use this to automatically set the granularity for the next block)
    tick_size = rng_get>max_array_dol_range?math.ceil(rng_get/max_array_dol_range)*syminfo.mintick:syminfo.mintick    //if the range is > max allowable difference, it scales accordingly, else, just use mintick
    
    c_hi = round_to(high,tick_size)                         //candle high value rounded to the nearest calculation tick
    c_lo = round_to(low,tick_size)                          //candle low value rounded to the nearest calculation tick
    candle_range = c_hi - c_lo                              //range of high and low value
    candle_index = (candle_range/tick_size)+1               //# of ticks within the range (add 1 because when we append on this index we want to start at 0 so range of 14 means start at 0, go to 14, so 15 total indexes)
    tick_vol = mp?1:math.round(volume/candle_index)         //splits the candle's cumulative volume amongst each candle index to give the distributed volume value. If using market profile, this value is 1
    
    //Start
    if tf_change                        // If new block
        array.clear(main)               //clear the main array
        base := c_lo                    //set the lowest vp value to == the low adjusted for tick size
        roof := c_hi                    //set highest vp value to == the high adjusted for tick size
        for i = 0 to candle_index-1     //and for every index in the current candle(since this is the first candle of the new block)
            array.push(main,tick_vol)   //push the tick volume into each array index for the amount of 
    //Expand Down
    down_dif = math.abs((base - c_lo)/tick_size)    //determine the difference (in ticks) between the candle low and the lowest vp value
    if c_lo < base                                  //if the candle low is less than the lowest vp value, we need to add indexes to the main array downwards 
        for i = 1 to down_dif                       // for 1 to down dif
            array.unshift(main,0)                   // add a 0 value to the front of the array
        base := c_lo                                // and the lowest vp value now == the candle low adjusted for tick size
    z_point = math.abs((base - c_lo)/tick_size)     //same as down_dif but by defining the variable here we get the info after the above loop has run (ex. on a candle when the loop runs down_dif might equal 3, but z_point will equal 0)
        
    //Expand Up
    up_dif = math.abs((roof - c_hi)/tick_size)      //exactly the same as above, just upwards instead of downwards
    if c_hi > roof                                  //
        for i = 1 to up_dif                         //
            array.push(main,0)                      //
        roof := c_hi                                //
    //h_point = math.abs((roof - c_hi)/tick_size)     //since everything starts from the bottom up, this variable is redundant and is not actually used anywhere. Was used in development to confirm the values are being properly compiled.
        
    //Input Values
    for i = 0 to array.size(main)                                   // for every index in our main array
        if (i >= z_point) and (i <= (z_point + candle_index)-1)     // if the index is inside of our candle's index
            v = array.get(main,int(i))                              // get the main array's index value
            array.set(main,int(i),v + tick_vol)                     // and add the tick volume to it

    max_index = math.round(math.avg(array.indexof(main,array.max(main)),array.lastindexof(main,array.max(main)))) // determine the last occurance and first occurance of the max value in our array, and give us the average index of teh 2.
    poc = base + (tick_size*max_index) //start at base add a tick for every index to the max index. this one reads pretty well. ^^Cont. Max value == POC index, but flat tops occur alot in this calcualtion method,due to the data available, this makes it determine 1 value vs only the first one it comes across.
    //Value Zones
    max_vol = array.sum(main)*vap                                                   //This is how much volume is in the value zone
    vol_count = max_index >=0?array.get(main, max_index):0.0                        //counter variable to count how much volume we have currently have accumulated, not declaring "var" resets this on every calculation, but in the loop below it will change the value of this while in the for loop but onyl give us 1 number in the end, and then recalc next tick.
    up_count = max_index                                                            //counter variable same as above, set to max index because we want to start at our poc and count the volume expanding outwards to determine the value zone.
    down_count = max_index                                                          //counter variable ^^
    for x = 0 to array.size(main)-1                                                 // for every index in out main array - 1
        if vol_count >= max_vol                                                     // if our volume counter is >= the volume in the value zone, we're done with this calculation, this loop repeats until this is true.
            break                                                                   
        uppervol = up_count<array.size(main)-1?array.get(main, up_count + 1):na     // grabs volume data (aka,  main array value) 1 above poc
        lowervol = down_count>0?array.get(main, down_count - 1):na                  // grabs ^same^ 1 below poc
        if ((uppervol >= lowervol) and not na(uppervol)) or na(lowervol)            // code reads well here
            vol_count += uppervol                                                   // add volume to volume count
            up_count += 1                                                           // tick our up counter + 1
        else                                                                        
            vol_count += lowervol                                                   // same  as above but down
            down_count -= 1                                                         //rinse and repeat
    val = base + (tick_size*down_count)                 //After the loop above, down_count == value low index
    vah = base + (tick_size*up_count)                   //<^These do the same thing as determining poc, up_count == value high index
    pd_vah = ta.valuewhen(tf_change,vah[1],0)           //find the block change, and take the last bar's value
    pd_val = ta.valuewhen(tf_change,val[1],0)           //
    pd_poc = ta.valuewhen(tf_change,poc[1],0)           //
    [poc,vah,val,pd_poc,pd_vah,pd_val,main,base,tick_size,up_count,down_count,max_index,roof]

[poc,vah,val,pd_poc,pd_vah,pd_val,main,base,tick_size,up_count,down_count,mv,roof] = vol_prof(tf,mdr)

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

day_len = ta.valuewhen(timeframe.change(tf),bar_index,0)-ta.valuewhen(timeframe.change(tf),bar_index,1)

var profile = array.new_line(na)    
if array.size(profile) > 0
    for i = 0 to array.size(profile) - 1
        line.delete(array.get(profile, i))
        if i == (array.size(profile) - 1)
            array.clear(profile)
var box_profile = array.new_box(na) 
if array.size(box_profile) > 0
    for i = 0 to array.size(box_profile) - 1
        box.delete(array.get(box_profile, i))
        if i == (array.size(box_profile) - 1)
            array.clear(box_profile)

min_array = array.copy(main)
if array.size(min_array) > 0
    for i = array.size(min_array)-1 to 0
        if array.get(min_array,i) == 0
            array.remove(min_array,i)

prof_color(_num) =>
    _num==mv?poc_color:
     (_num==up_count or _num==down_count)?var_color:
     array.get(main,_num) == array.min(min_array)?sp_color:
     (_num>up_count or _num<down_count)?ov_color:
     vaz_color
     
bi_nd = ta.valuewhen(timeframe.change(tf),bar_index,0)
if barstate.islast
    if array.size(main) > 0
        for i = 0 to array.size(main) - 1
            scale = disp_size/array.max(main)
            scaled = math.round(array.get(main,i)*scale)
            if ((i>up_count) or (i<down_count)) or (array.size(box_profile) >= 450)
                array.push(profile,line.new(bar_index+prof_offset,base+(i*tick_size),(bar_index+scaled)+prof_offset,base+(i*tick_size), color = prof_color(i), style = (i<down_count or i>up_count?line.style_dotted:line.style_solid)))
            else
                array.push(box_profile,box.new(bar_index+prof_offset,base+(i*tick_size),(bar_index+scaled)+prof_offset,base+(i*tick_size), border_color = prof_color(i), border_style = (i<down_count or i>up_count?line.style_dotted:line.style_solid), border_width = 1))

var pd_lines = array.new_line(na)
if timeframe.change(tf) and hist
    array.push(pd_lines,line.new(bar_index-day_len,pd_poc,bar_index-1,pd_poc,color = poc_color, width = 2))
    array.push(pd_lines,line.new(bar_index-day_len,pd_vah,bar_index-1,pd_vah,color = var_color, width = 2))
    array.push(pd_lines,line.new(bar_index-day_len,pd_val,bar_index-1,pd_val,color = var_color, width = 2))
if array.size(pd_lines) > 90
    line.delete(array.get(pd_lines,0))
    array.remove(pd_lines,0)
if extend_day
    d_poc = line.new(bi_nd,poc,bar_index,poc,color = poc_color, width = 2)
    d_vah = line.new(bi_nd,vah,bar_index,vah,color = var_color, width = 2)
    d_val = line.new(bi_nd,val,bar_index,val,color = var_color, width = 2)
    line.delete(d_poc[1])
    line.delete(d_vah[1])
    line.delete(d_val[1])

lab = label.new(bar_index+prof_offset,roof, text = (mp?"Market Profile [":"Volume Profile [") + tf + "]\nGranularity: " + str.tostring(tick_size,"$#.##########"), style = (disp_size<0?label.style_label_lower_right:label.style_label_lower_left), color = color.rgb(0,0,0,100), textcolor = chart.fg_color, textalign = (disp_size<0?text.align_left:text.align_right), text_font_family = font.family_monospace)
label.delete(lab[1])

alertcondition(ta.crossover(close,poc), "Cross-Over Point of Control")
alertcondition(ta.crossunder(close,poc), "Cross-Under Point of Control")
alertcondition(ta.crossover(close,vah), "Cross-Over Value High")
alertcondition(ta.crossunder(close,vah), "Cross-Under Value High")
alertcondition(ta.crossover(close,val), "Cross-Over Value Low")
alertcondition(ta.crossunder(close,val),"Cross-Under Value Low")
